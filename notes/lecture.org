#+title: Lecture Notes
#+startup: show3levels
* introduction :week_1:
** ADT
+ string
+ vector
+ bag
+ stack
*** eg
**** stack
| push |   | pop |
| ---- |   | --- |
|      | 3 |     |
|      | 2 |     |
|      | 1 |     |
**** operations (atomic actions)
+ push
+ pop
+ top
+ empty
+ create
** c++ implementation
+ [ ] classes / objects
+ [ ] encapsulation
+ [ ] inheritance
+ [ ] polymorphism
+ [ ] pointers
*** object
+ data structure with methods
+ can use class / template class to define ADT
*** data encapsulation
+ instantiation of a class, creating an entity that can be used in a program
*** information hiding
*** inheritance
+ forms a hierarchy
+ "is-a" relationship
*** polymorphism
*** pointers
+ variable is defined by
  1. what it stores
  2. its location in memory
**** dereference
#+begin_src c
p_ptr = &i;
p_val = *p_ptr;
#+end_src
**** after using
#+begin_src c
p_ptr = new int;
delete p_ptr;
#+end_src
**** after deleting
#+begin_src c
p_ptr = NULL;
p_ptr = 0;
#+end_src
**** leaks
#+begin_src c
p_ptr = new int;
p_ptr = new int;
#+end_src
**** copy constructors
+ deep copy vs shallow copy
**** pointers vs ref variables
+ can change value of pointer vs value of (eg) integer
* complexity :week_2:
** complexity
*** asymptotic
+ $y = \tan x$
  $x = \frac\pi2$
+ as $n \to \infty$
*** measure
**** time
amount time as function of n
**** space
amount memory as function of n
*** example
**** $f(n) = n^2 + 100n + \log_{10}n + 1000$
+ $f(1) = 1 + 100 + 0 + 1000 = 1101$
+ $f(100) = 10000 + 10000 + 2 + 1000 = 21002$
$\implies n^2$ dominates
*** math
$f(n) = O(g(n)) \iff \exists c\in\mathbb{R}, N\in\mathbb{N} \: \forall n < N \: \colon \: 0 \le f(n) \le cg(n) \: \forall n>N$
** 4 common ops
1. insert
2. delete
   + typically requires search
3. search
4. sort

** classes
*** $O(n)$
+ $n =$ length of list
**** cases
***** worst $O(n)$
not in list
***** best $O(1)$
first item
***** average $O(\frac{n}2) = O(n)$
*** $O(n \log_a n)$
*** $O(\log_a n)$
*** $O(n^2)$
*** $O(a^n)$
** bounds
*** $O(n)$ greatest upper bound
**** pf
want $c,N$ s.t.  $3n^2 + 4n - 2 \le cn^2$ $\forall n\ge N$
$\implies 3 + \frac4n - \frac2{ n^2 } \le c$
set $N=1$
$\implies 3 + \frac4n - \frac2{ n^2 } \le 5$
choose $c=5$
**** transitive
$f(n) = O(g(n))$
$g(n) = O(h(n))$
$\implies f(n) = O(h(n))$
**** ?? :exam:
$f(n) = O(h(n))$
$g(n) = O(h(n))$
$\implies f(n) + g(n) = O(h(n))$
**** any $k^\text{th}$ deg poly of $n$ is $O(n^{k+j})$ $\forall j>0$
*** $\Theta(n)$ both :exam:
*** $\Omega(n)$ greatest lowest bound :exam:
** logarithm
*** $\lg$ binary
*** $\log$ decimal
*** $\ln$ euler
** recursive
*** linear
$T(n) = kn$
$T(n) = 2\cdot T(\frac{n}2)$
*** log
$T(n) = T(n/2) + k$
$\implies O(\log n)$
*** line arithmetic
$T(n)=2*T(n/2)+O(n)$
$\implies O(n\log n)$
*** quadratic
$O(n^2)$
$T(n) = T(n-1) + O(n)$
*** exponential
$T(n)=T(n-1)*k$
$O(k^n)$
** eg
$f(n)=3n^2$
$g(n)=5n^2$
$f(n)=O(g(n))$
$g(n)=\Omega(f(n))$
* recursion :week_3:
** recursion
*** head recursion
recurse first, then compute
*** tail recursion
compute first, then recurse
** eg
*** gcd
#+begin_src haskell
import Text.Printf ( printf )

gcd1:: Integer -> Integer -> Integer
gcd1 a b
  | b < a = gcd1 b a
  | otherwise = gcd1 (b `mod` a) a

fib:: Integer -> Integer
fib n
  | n < 2 = n
  | otherwise = (fib (n-1)) + (fib (n-2))

main = printf "hi"
#+end_src
** order
*** preorder
*** midorder
*** postorder
** nontail recursion
*** iterative
1. implement stack
2. less clarity & brevity
3. aoeu
** indirect recursion
** excessive recursion
*** fibonacci
+ default = $\phi^n$
+ also $O(n), O(\log{n})$
* sorting :week_4:
|------------+---+-----------------------------|
| name       |   | complexity                  |
|------------+---+-----------------------------|
| bubble     |   | O(n^2)                      |
| selection  |   | O(n^2)                      |
| insertion  |   | O(n^2)                      |
| shellsort  |   | between O(nlogn) O(n^2)     |
| merge sort |   | O(nlogn)                    |
| quicksort  |   | O(nlogn)                    |
| radix sort |   | O(n) <- not really O(nlogn) |
|------------+---+-----------------------------|
** bubble
1. compare to nearest
2. swap when out order
+ n elements => n sweeps
+ add `bool didSwap` for more efficiency
** selection
1. swap with smallest remaining value
** insertion
** shellsort
comparison sort
** merge sort
1. sort left half
2. sort right half
3. merge both
takes log_2(n) steps
each step takes n steps
so O(nlogn)
** quicksort :exam:
1. choose pivot
2. partition list
3. quicksort left
4. quicksort right
|    |    |    | p1 |    |    |
|    | p2 |    | p1 | p2 |    |
| p3 | p2 | p3 | p1 | p2 | p3 |

** cases
*** best :exam:
*** average :exam:
*** worst :exam:

* lists, stacks, queues :week_5:
** Lists
+ payload: value ðŸ™‚
+ node: contains payload ðŸ”³
+ linked list: head
*** Pointer
| 0 | 1 | 2 | 3 | 4 | 5 | 6 | ... |
*** Singly Linked
| 0 | -> | 1 | -> | 2 | -> | 3 | -> | ... |
#+begin_src cpp
class IntSLLNode {
public:
        IntSSLNode() {
                next = 0;
        }
        IntSLLNode(int i, IntSLLNode *in = 0) {
                info = i;
                next = in;
        }
        int getInfo() {
            return info;
        }
private:
        int info;
        IntSLLNode *next;
};

int main () {
    IntSLLNode head(99);
    std::cout << head->getInfo() << std::endl;
    return 0;
}
#+end_src
#+RESULTS:
:results:
:end:
**** DUMMY
+ always in list
+ list empty when both head and tail = dummy

*** Doubly Linked
| 0 | <-> | 1 | <-> | 2 | <-> | 3 | <-> | ... |
** Stacks
| ðŸ‘¨ |
| ðŸ¶ |
| ðŸ¸ |
| ðŸ˜œ |
|-----|
+ one-dimensional
+ LIFO: last in first out
*** primitive/atomic actions
+ push: payload
+ pop: payload -> void
+ is_empty: bool
** Queues
*** fifo
|----------+---+---+---+---+---+---+---+----------|
| back     |   |   |   |   |   |   |   | front    |
|----------+---+---+---+---+---+---+---+----------|
| ^ insert |   |   |   |   |   |   |   | ^ remove |
|----------+---+---+---+---+---+---+---+----------|
* hash tables :week_6:
+ $o(1)$
** keys
*** hash
** bucket
** functions
*** modular arithmetic
$h(k) = (k \mod p) \mod tableSize$
*** folding
$x \implies (\text{fold}\circ\text{pad})(x)$
$123-45-6789 \to 123 + 456 + 789 \mod{tableSize} = 1368 \mod{tableSize}$
**** shift
**** boundary
*** mid-square
1. square key
$key = 101$
$key^2 = 10201$
2. extract middle part
$part = 020$
** collision resolution
*** chaining
+ linked list of nodes
+ worst case: $O(|K|)$
