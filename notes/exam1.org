#+title: Exam1
* recursion
** tail
recursive call occurs at very end
** non-tail
recursive call does not occur at very end
** indirect
calls another function that calls self
* sort
** bubble
** selection
1. find index_smallest unsorted
2. swap if necessary
** insertion
1. for each index, search backwards for greater value
** shell
+ of the array are Insertion-sorted separately based on a “gap length,” the distance between elements in the array
+ each sub-array in the list is sorted, the gap length is
shortened and Insertion sort is performed again
+ the sub-arrays are sorted, the number of swaps needed
to sort the larger “partially” sorted sub-arrays based on
+ gap length is less than it would be for random values
+ gap length eventually becomes 1 (no gap) and the array is
sorted
** merge
+ In the base case, you have only 1 or 2 items to sort in O(1) time
+ merge step consists of looking at the leftmost (smallest) remaining value in each half-sized list, and removing the smaller of those two values and placing in the leftmost open spot in the sorted list – like “zippering” them together!
+ This algorithm requires extra space the size of the original list, which is O(n) additional space complexity
*** steps
1. Sort the left half of the list using Merge Sort
2. the right half of the list using Merge Sort
3. Merge the two half-sized sorted lists into a sorted list
** quick
+ does work before recursion
+ selects pivot
+ places pivot in correct place
*** steps
** radix
+ sort by digits
